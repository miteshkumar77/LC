{"id":345424580,"lang":"cpp","time":"1 year, 10 months","timestamp":1590591369,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/345424580/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"N/A","code":"class Solution {\npublic:\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        \n        vector<list<int> > graph(N + 1, list<int>()); \n        for (vector<int> edge : dislikes) {\n            graph[edge[0]].push_back(edge[1]); \n            graph[edge[1]].push_back(edge[0]); \n        }\n        \n        vector<int> color(N + 1, -1); \n        \n        queue<int> bfsq; \n        bfsq.push(dislikes[0][0]);\n        color[bfsq.front()] = 0; \n        while(!bfsq.empty()) {\n            int top = bfsq.front();\n            int curr_color = color[top]; \n            int n_color = (curr_color == 0)?1:0; \n            bfsq.pop(); \n            for (int neighbor : graph[top]) {\n                if (curr_color == color[neighbor]) {\n                    return false; \n                } else if (color[neighbor] == -1) {\n                    color[neighbor] = n_color; \n                    bfsq.push(neighbor); \n                }\n            }\n        }\n        \n        return true; \n        \n    }\n};","compare_result":"111100000000000000000000000000000000000000000000000000000000000000","title_slug":"possible-bipartition"}