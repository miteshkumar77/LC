{"id":345426221,"lang":"cpp","time":"1 year, 10 months","timestamp":1590591664,"status_display":"Accepted","runtime":"444 ms","url":"/submissions/detail/345426221/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"83 MB","code":"class Solution {\npublic:\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        \n        vector<list<int> > graph(N + 1, list<int>()); \n        for (vector<int> edge : dislikes) {\n            graph[edge[0]].push_back(edge[1]); \n            graph[edge[1]].push_back(edge[0]); \n        }\n        \n        vector<int> color(N + 1, -1); \n        \n        queue<int> bfsq; \n        \n        for (int i = 1; i < color.size(); ++i) {\n            if (color[i] == -1) {\n                bfsq.push(i); \n                color[i] = 1; \n            }\n            while(!bfsq.empty()) {\n                int top = bfsq.front();\n                int curr_color = color[top]; \n                int n_color = (curr_color == 0)?1:0; \n                bfsq.pop(); \n                for (int neighbor : graph[top]) {\n                    if (curr_color == color[neighbor]) {\n                        return false; \n                    } else if (color[neighbor] == -1) {\n                        color[neighbor] = n_color; \n                        bfsq.push(neighbor); \n                    }\n                }\n            }\n        }\n\n            return true; \n        \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition"}