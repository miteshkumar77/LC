{"id":398516182,"lang":"cpp","time":"1 year, 6 months","timestamp":1600647326,"status_display":"Accepted","runtime":"224 ms","url":"/submissions/detail/398516182/","is_pending":"Not Pending","title":"Design HashMap","memory":"45.5 MB","code":"class MyHashMap {\nprivate:\n    \n\n    template <class K, class V>\nclass HashMap {\npublic: \n    HashMap(double occupancy_ratio = 0.7, int initial_size = 100) : f(occupancy_ratio) {\n        K def; \n        data = vector<tuple<bool,bool,K>>(initial_size, tuple<bool,bool,K>(false, false, def)); \n        values = vector<V>(initial_size);\n        occupied = 0; \n        size = 0; \n    }\n    \n    \n    bool insert(K key, V val) {\n        rehash(); \n        int init_idx = search(key); \n        \n        if (std::get<0>(data[init_idx]) && std::get<2>(data[init_idx]) == key) {\n            return false; \n        }\n        \n        int insert_idx = searchInsert(key); \n        if (!std::get<1>(data[insert_idx])) {\n            ++occupied; \n        }\n        \n        data[insert_idx] = make_tuple(true, true, key); \n        values[insert_idx] = val;\n        ++size; \n        return true; \n    }\n    \n    pair<bool, V> getVal(K key) {\n        int init_idx = search(key); \n        if (std::get<0>(data[init_idx]) && std::get<2>(data[init_idx]) == key) {\n            return make_pair(true, values[init_idx]);\n        }\n        return make_pair(false, 0); \n    }\n\n\n    void set(K key, V val) {\n        rehash(); \n        int init_idx = search(key); \n        if (std::get<0>(data[init_idx]) && std::get<2>(data[init_idx]) == key) {\n            values[init_idx] = val;\n            return;\n        }\n        insert(key, val); \n    }\n\n    bool contains(K key) {\n        int init_idx = search(key); \n        \n        if (std::get<0>(data[init_idx]) && std::get<2>(data[init_idx]) == key) {\n            return true; \n        }\n        return false; \n    }\n    \n    \n    bool erase(K val) {\n        int first_occ = search(val); \n        if (!std::get<1>(data[first_occ]) || !std::get<0>(data[first_occ])) {\n            return false; \n        }\n        \n        if (std::get<2>(data[first_occ]) == val) {\n            --size; \n            data[first_occ] = make_tuple(false, true, val); \n            return true; \n        }\n        return false; \n    }\n    \n    \n    \n    \n\n    \n    \nprivate: \n    \n    \n    int searchInsert(K val) {\n        int hval = mhash(val); \n        int x = 0; \n        int idx = (hval % data.size() + P(x)) % data.size(); \n        \n        while(std::get<0>(data[idx])) {\n            ++x; \n            idx = (hval % data.size() + P(x)) % data.size(); \n        }\n        return idx; \n    }\n    \n    int search(K val) {\n        int hval = mhash(val); \n        int x = 0; \n        int idx = (hval % data.size() + P(x)) % data.size(); \n        while(std::get<1>(data[idx])) {\n            if (std::get<0>(data[idx]) && std::get<2>(data[idx]) == val) {\n                return idx; \n            }\n            ++x; \n            idx = (hval % data.size() + P(x)) % data.size(); \n        }\n        \n        return idx; \n    }\n    \n    int P(int x) {\n        return x; \n    }\n    \n    void rehash() {\n        if (((double)size)/data.size() < f) {\n            return; \n        }\n\n        K def; \n        vector<tuple<bool,bool,K>> n_data(data.size() * 2, tuple<bool, bool, K>(false, false, def)); \n        vector<V> n_values(data.size() * 2);\n        data.swap(n_data); \n        values.swap(n_values); \n        size = 0; \n        occupied = 0; \n        int i = 0; \n        for (auto [isOccupied, tomb, key] : n_data) {\n            if (isOccupied) {\n                insert(key, n_values[i]); \n            } \n            ++i;\n        }\n    }\n    \n    \n    int mhash(const K& val) {\n        \n        return hash<K>{}(val);  \n    }\n    \n    \n    \n    vector<tuple<bool,bool,K>> data;\n    vector<V> values;  \n    int size; \n    int occupied; \n    double f; \n    \n};\npublic:\n    /** Initialize your data structure here. */\n    MyHashMap() {\n        \n    }\n    \n    /** value will always be non-negative. */\n    void put(int key, int value) {\n        m_hm.set(key, value); \n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    int get(int key) {\n        // cout << \"get \" << key << endl; \n        auto p = m_hm.getVal(key); \n        if (p.first) {\n            return p.second;\n        }\n        return -1; \n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    void remove(int key) {\n        // cout << \"remove \" << key << endl; \n        m_hm.erase(key); \n    }\n    \nprivate:\n    HashMap<int,int> m_hm; \n};\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj->put(key,value);\n * int param_2 = obj->get(key);\n * obj->remove(key);\n */\n","compare_result":"111111111111111111111111111111111","title_slug":"design-hashmap"}