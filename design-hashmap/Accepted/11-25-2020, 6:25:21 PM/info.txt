{"id":424121812,"lang":"golang","time":"1 year, 4 months","timestamp":1606346721,"status_display":"Accepted","runtime":"112 ms","url":"/submissions/detail/424121812/","is_pending":"Not Pending","title":"Design HashMap","memory":"7.5 MB","code":"package main\n\n// SizeType used for size properties\ntype SizeType = uint64\n\n// IndexType used for indexing the map\ntype IndexType = uint64\n\n// RatioType used for fractional properties\ntype RatioType = float32\n\n// KeyType used for the key's type\ntype KeyType = int\n\n// ValueType used for the value's type\ntype ValueType = int\n\n///---------------------------------------------------------------------------------------------------------\n// hashElement class BEGIN\n\ntype hashElement struct {\n\tisOccupied bool\n\tisTomb     bool\n\tkey        KeyType\n\tvalue      ValueType\n}\n\nfunc (element *hashElement) init() {\n\telement.isOccupied = false\n\telement.isTomb = false\n}\n\n// hashElement class END\n///---------------------------------------------------------------------------------------------------------\n\n///---------------------------------------------------------------------------------------------------------\n// hashShard class BEGIN\n\ntype hashShard struct {\n\toccupancyRatio RatioType\n\toccupied       SizeType\n\tsize           SizeType\n\tdata           *[]hashElement\n\thashFunc       *func(KeyType) IndexType\n}\n\n/// Private\n\n// CallBackIterator calls a callback function cb for every element in the map\n// in no particular order\nfunc (shard *hashShard) shardCallBackIterator(cb *func(interface{})) {\n\tfor i := 0; i < len(*shard.data); i++ {\n\t\tif (*shard.data)[i].isOccupied {\n\t\t\t(*cb)((*shard.data)[i].value)\n\t\t}\n\t}\n}\n\n// Insert inserts a key value pair into the collection\nfunc (shard *hashShard) shardInsert(key KeyType, hashValue IndexType, value ValueType) bool {\n\tshard.rehash()\n\tinitIdx := shard.searchExists(key, hashValue)\n\n\tif (*shard.data)[initIdx].isOccupied && (*shard.data)[initIdx].key == key {\n\t\treturn false\n\t}\n\n\tinsertIdx := shard.searchToInsert(key, hashValue)\n\tif !(*shard.data)[insertIdx].isOccupied {\n\t\tshard.occupied++\n\t}\n\n\t(*shard.data)[insertIdx] = hashElement{true, true, key, value}\n\tshard.size++\n\treturn true\n}\n\n// GetVal returns (true, value) if key exists, otherwise (false, nil)\nfunc (shard *hashShard) shardGetVal(key KeyType, hashValue IndexType) (bool, ValueType) {\n\tinitIdx := shard.searchExists(key, hashValue)\n\tif (*shard.data)[initIdx].isOccupied && (*shard.data)[initIdx].key == key {\n\t\treturn true, (*shard.data)[initIdx].value\n\t}\n\tvar def ValueType\n\treturn false, def\n}\n\n// Set key's value to value, whether it exists or not\nfunc (shard *hashShard) shardSet(key KeyType, hashValue IndexType, value ValueType) {\n\tshard.rehash()\n\tinitIdx := shard.searchExists(key, hashValue)\n\tif (*shard.data)[initIdx].isOccupied && (*shard.data)[initIdx].key == key {\n\t\t(*shard.data)[initIdx].value = value\n\t\treturn\n\t}\n\tshard.shardInsert(key, hashValue, value)\n}\n\n// Contains returns true iff the map contains key\nfunc (shard *hashShard) shardContains(key KeyType, hashValue IndexType) bool {\n\tinitIdx := shard.searchExists(key, hashValue)\n\tif (*shard.data)[initIdx].isOccupied && (*shard.data)[initIdx].key == key {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// Erase deletes the key, value pair from the collection iff it exists, and return true\n// otherwise it returns false\nfunc (shard *hashShard) shardErase(key KeyType, hashValue IndexType) bool {\n\tfirstOcc := shard.searchExists(key, hashValue)\n\tif !(*shard.data)[firstOcc].isTomb || !(*shard.data)[firstOcc].isOccupied {\n\t\treturn false\n\t}\n\n\tif (*shard.data)[firstOcc].key == key {\n\t\tshard.size--\n\t\t(*shard.data)[firstOcc].isOccupied = false\n\t\t(*shard.data)[firstOcc].isTomb = true\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (shard *hashShard) init(occupancyRatio RatioType, initialSize SizeType, hashFunc *func(KeyType) IndexType) {\n\tshard.occupancyRatio = occupancyRatio\n\tshard.occupied, shard.size = 0, 0\n\ttmp := make([]hashElement, initialSize)\n\tshard.data = &tmp\n\tshard.hashFunc = hashFunc\n\tfor i := 0; i < len(*shard.data); i++ {\n\t\t(*shard.data)[i].init()\n\t}\n}\n\n// searchToInsert walks forward from a particular key's hash index until the next unoccupied index\nfunc (shard *hashShard) searchToInsert(key KeyType, hashValue IndexType) IndexType {\n\t// hval := shard.mhash(key)\n\tvar x IndexType = 0\n\tidx := (hashValue%IndexType(len(*shard.data)) + shard.probe(x)) % IndexType(len(*shard.data))\n\n\tfor (*shard.data)[idx].isOccupied {\n\t\tx++\n\t\tidx = (hashValue%IndexType(len(*shard.data)) + shard.probe(x)) % IndexType(len(*shard.data))\n\t}\n\treturn idx\n}\n\n// searchExists walks forward from a particular key's hash index until the next non-tomb index\nfunc (shard *hashShard) searchExists(key KeyType, hashValue IndexType) IndexType {\n\tvar x IndexType = 0\n\tvar idx = (hashValue%IndexType(len(*shard.data)) + shard.probe(x)) % IndexType(len(*shard.data))\n\tfor (*shard.data)[idx].isTomb {\n\t\tif (*shard.data)[idx].isOccupied && (*shard.data)[idx].key == key {\n\t\t\treturn idx\n\t\t}\n\t\tx++\n\t\tidx = (hashValue%IndexType(len(*shard.data)) + shard.probe(x)) % IndexType(len(*shard.data))\n\t}\n\n\treturn idx\n}\n\nfunc (shard *hashShard) mhash(key KeyType) IndexType {\n\treturn (*shard.hashFunc)(key)\n}\n\nfunc (shard *hashShard) probe(x IndexType) IndexType {\n\treturn x\n}\n\nfunc (shard *hashShard) rehash() {\n\tif RatioType(shard.occupied)/RatioType(len(*shard.data)) < shard.occupancyRatio {\n\t\treturn\n\t}\n\n\ttmp := make([]hashElement, len(*shard.data)*2)\n\tnData := &tmp\n\n\tfor i := 0; i < len(*nData); i++ {\n\t\t(*nData)[i].init()\n\t}\n\n\tnData, shard.data = shard.data, nData\n\tshard.size = 0\n\tshard.occupied = 0\n\n\tfor i := 0; i < len(*nData); i++ {\n\t\tif (*nData)[i].isOccupied {\n\t\t\tshard.shardInsert((*nData)[i].key, shard.mhash((*nData)[i].key), (*nData)[i].value)\n\t\t}\n\t}\n}\n\n// hashShard class END\n///---------------------------------------------------------------------------------------------------------\n\n///---------------------------------------------------------------------------------------------------------\n// HashMap class BEGIN\n\n// HashMap is a thread safe key value O(1) look up data structure\ntype HashMap struct {\n\thashFunc *func(KeyType) IndexType\n\tshards   []hashShard\n}\n\n/// Public\n\n// CreateNewHashMap creates a new empty hashmap\nfunc CreateNewHashMap(occupancyRatio RatioType,\n\tinitialSize SizeType,\n\thashFunc func(KeyType) IndexType, shards SizeType) HashMap {\n\tret := HashMap{}\n\tret.init(occupancyRatio, initialSize, hashFunc, shards)\n\treturn ret\n}\n\n// CallBackIterator calls a callback function cb for every element in the map\n// in no particular order\nfunc (table *HashMap) CallBackIterator(cb func(interface{})) {\n\tfor _, shard := range table.shards {\n\t\tshard.shardCallBackIterator(&cb)\n\t}\n}\n\n// Insert inserts a key value pair into the collection if it does not exist\n// and returns true, otherwise just returns false\nfunc (table *HashMap) Insert(key KeyType, value ValueType) bool {\n\thashValue := table.mhash(key)\n\tshard := table.getShard(hashValue)\n\n\treturn table.shards[shard].shardInsert(key, hashValue, value)\n}\n\n// GetVal returns (true, value) if key exists, otherwise (false, nil)\nfunc (table *HashMap) GetVal(key KeyType) (bool, ValueType) {\n\thashValue := table.mhash(key)\n\tshard := table.getShard(hashValue)\n\n\treturn table.shards[shard].shardGetVal(key, hashValue)\n}\n\n// Set key's value to value, whether it exists or not\nfunc (table *HashMap) Set(key KeyType, value ValueType) {\n\thashValue := table.mhash(key)\n\tshard := table.getShard(hashValue)\n\n\ttable.shards[shard].shardSet(key, hashValue, value)\n}\n\n// Contains returns true iff the map contains key\nfunc (table *HashMap) Contains(key KeyType) bool {\n\thashValue := table.mhash(key)\n\tshard := table.getShard(hashValue)\n\n\treturn table.shards[shard].shardContains(key, hashValue)\n}\n\n// Erase deletes the key, value pair from the collection iff it exists, and return true\n// otherwise it returns false\nfunc (table *HashMap) Erase(key KeyType) bool {\n\thashValue := table.mhash(key)\n\tshard := table.getShard(hashValue)\n\n\treturn table.shards[shard].shardErase(key, hashValue)\n}\n\n/// Private\n\n// getShard gets the shard associated with a hash value of a particular key\nfunc (table *HashMap) getShard(hashValue IndexType) IndexType {\n\treturn hashValue % IndexType(len(table.shards))\n}\n\nfunc (table *HashMap) init(occupancyRatio RatioType, initialSize SizeType, hashFunc func(KeyType) IndexType, shards SizeType) {\n\n\ttable.shards = make([]hashShard, shards)\n\ttable.hashFunc = &hashFunc\n\tfor i := 0; i < len(table.shards); i++ {\n\t\t(table.shards)[i].init(occupancyRatio, initialSize, &hashFunc)\n\t}\n\n}\n\nfunc (table *HashMap) mhash(key KeyType) IndexType {\n\treturn (*table.hashFunc)(key)\n}\n\n// HashMap class END\n///---------------------------------------------------------------------------------------------------------\n\n\n\n\ntype MyHashMap struct {\n    m_hm HashMap\n    // m_hm map[int]int\n}\n\nfunc hs(i int) IndexType {\n        \n        b := make([]byte, 8)\n    binary.LittleEndian.PutUint64(b, uint64(i))\n        h := fnv.New64()\n        h.Write([]byte(b))\n        return IndexType(h.Sum64())\n}\n\n/** Initialize your data structure here. */\nfunc Constructor() MyHashMap {\n    var m MyHashMap\n    m.m_hm = CreateNewHashMap(0.7, 100, func(key int) IndexType {\n        return hs(key)\n    }, 2)\n    return m\n    \n    // return MyHashMap{make(map[int]int)}\n}\n\n\n/** value will always be non-negative. */\nfunc (this *MyHashMap) Put(key int, value int)  {\n    this.m_hm.Set(key, value)\n    // this.m_hm[key] = value\n}\n\n\n/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\nfunc (this *MyHashMap) Get(key int) int {\n    exists, val := this.m_hm.GetVal(key)\n    if exists {\n        return val\n    }\n    return -1\n    \n    // value, exists := this.m_hm[key]\n    // if exists {\n    //     return value\n    // }\n    // return -1\n}\n\n\n/** Removes the mapping of the specified value key if this map contains a mapping for the key */\nfunc (this *MyHashMap) Remove(key int)  {\n    this.m_hm.Erase(key)\n    // delete(this.m_hm, key)\n}\n\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Put(key,value);\n * param_2 := obj.Get(key);\n * obj.Remove(key);\n */","compare_result":"111111111111111111111111111111111","title_slug":"design-hashmap"}