{"id":423133199,"lang":"golang","time":"1 year, 4 months","timestamp":1606095034,"status_display":"Accepted","runtime":"120 ms","url":"/submissions/detail/423133199/","is_pending":"Not Pending","title":"Design HashMap","memory":"8 MB","code":"type sizeType = uint64\ntype indexType = uint64\ntype ratioType = float32\n\n///---------------------------------------------------------------------------------------------------------\n// hashElement class BEGIN\n\ntype hashElement struct {\n\tisOccupied bool\n\tisTomb     bool\n\tkey        interface{}\n\tvalue      interface{}\n}\n\nfunc (element *hashElement) init() {\n\telement.isOccupied = false\n\telement.isTomb = false\n}\n\n// hashElement class END\n///---------------------------------------------------------------------------------------------------------\n\n///---------------------------------------------------------------------------------------------------------\n// HashMap class BEGIN\n\n// HashMap is a thread safe key value O(1) look up data structure\ntype HashMap struct {\n\toccupancyRatio ratioType\n\toccupied       sizeType\n\tsize           sizeType\n\tdata           *[]hashElement\n\thashFunc       *func(interface{}) indexType\n}\n\n/// Public\n\n// CreateNewHashMap creates a new empty hashmap\nfunc CreateNewHashMap(occupancyRatio ratioType,\n\tinitialSize sizeType,\n\thashFunc func(interface{}) indexType) HashMap {\n\tret := HashMap{}\n\tret.init(occupancyRatio, initialSize, hashFunc)\n\treturn ret\n}\n\n// Insert inserts a key value pair into the collection\nfunc (table *HashMap) Insert(key interface{}, value interface{}) bool {\n\ttable.rehash()\n\tinitIdx := table.searchExists(key)\n\n\tif (*table.data)[initIdx].isOccupied && (*table.data)[initIdx].key == key {\n\t\treturn false\n\t}\n\n\tinsertIdx := table.searchToInsert(key)\n\tif !(*table.data)[insertIdx].isOccupied {\n\t\ttable.occupied++\n\t}\n\n\t(*table.data)[insertIdx] = hashElement{true, true, key, value}\n\ttable.size++\n\treturn true\n}\n\n// GetVal returns (true, value) if key exists, otherwise (false, nil)\nfunc (table *HashMap) GetVal(key interface{}) (bool, interface{}) {\n\tinitIdx := table.searchExists(key)\n\tif (*table.data)[initIdx].isOccupied && (*table.data)[initIdx].key == key {\n\t\treturn true, (*table.data)[initIdx].value\n\t}\n\treturn false, nil\n}\n\n// Set key's value to value, whether it exists or not\nfunc (table *HashMap) Set(key interface{}, value interface{}) {\n\ttable.rehash()\n\tinitIdx := table.searchExists(key)\n\tif (*table.data)[initIdx].isOccupied && (*table.data)[initIdx].key == key {\n\t\t(*table.data)[initIdx].value = value\n\t\treturn\n\t}\n\ttable.Insert(key, value)\n}\n\n// Contains returns true iff the map contains key\nfunc (table *HashMap) Contains(key interface{}) bool {\n\tinitIdx := table.searchExists(key)\n\tif (*table.data)[initIdx].isOccupied && (*table.data)[initIdx].key == key {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// Erase deletes the key, value pair from the collection iff it exists, and return true\n// otherwise it returns false\nfunc (table *HashMap) Erase(key interface{}) bool {\n\tfirstOcc := table.searchExists(key)\n\tif !(*table.data)[firstOcc].isTomb || !(*table.data)[firstOcc].isOccupied {\n\t\treturn false\n\t}\n\n\tif (*table.data)[firstOcc].key == key {\n\t\ttable.size--\n\t\t(*table.data)[firstOcc].isOccupied = false\n\t\t(*table.data)[firstOcc].isTomb = true\n\t\treturn true\n\t}\n\treturn false\n}\n\n/// Private\n\n// searchToInsert walks forward from a particular key's hash index until the next unoccupied index\nfunc (table *HashMap) searchToInsert(key interface{}) indexType {\n\thval := table.mhash(key)\n\tvar x indexType = 0\n\tidx := (hval%indexType(len(*table.data)) + table.probe(x)) % indexType(len(*table.data))\n\n\tfor (*table.data)[idx].isOccupied {\n\t\tx++\n\t\tidx = (hval%indexType(len(*table.data)) + table.probe(x)) % indexType(len(*table.data))\n\t}\n\treturn idx\n}\n\n// searchExists walks forward from a particular key's hash index until the next non-tomb index\nfunc (table *HashMap) searchExists(key interface{}) indexType {\n\thval := table.mhash(key)\n\tvar x indexType = 0\n\tvar idx = (hval%indexType(len(*table.data)) + table.probe(x)) % indexType(len(*table.data))\n\tfor (*table.data)[idx].isTomb {\n\t\tif (*table.data)[idx].isOccupied && (*table.data)[idx].key == key {\n\t\t\treturn idx\n\t\t}\n\t\tx++\n\t\tidx = (hval%indexType(len(*table.data)) + table.probe(x)) % indexType(len(*table.data))\n\t}\n\n\treturn idx\n}\n\nfunc (table *HashMap) init(occupancyRatio ratioType, initialSize sizeType, hashFunc func(interface{}) indexType) {\n\ttable.occupancyRatio = occupancyRatio\n\ttable.occupied, table.size = 0, 0\n\ttmp := make([]hashElement, initialSize)\n\ttable.data = &tmp\n\ttable.hashFunc = &hashFunc\n\tfor i := 0; i < len(*table.data); i++ {\n\t\t(*table.data)[i].init()\n\t}\n}\n\nfunc (table *HashMap) mhash(key interface{}) indexType {\n\treturn (*table.hashFunc)(key)\n}\n\nfunc (table *HashMap) probe(x indexType) indexType {\n\treturn x\n}\n\nfunc (table *HashMap) rehash() {\n\tif ratioType(table.occupied)/ratioType(len(*table.data)) < table.occupancyRatio {\n\t\treturn\n\t}\n\n\ttmp := make([]hashElement, len(*table.data)*2)\n\tnData := &tmp\n\n\tfor i := 0; i < len(*nData); i++ {\n        (*nData)[i].init()\n\t}\n\n\tnData, table.data = table.data, nData\n\ttable.size = 0\n\ttable.occupied = 0\n\n\tfor i := 0; i < len(*nData); i++ {\n\t\tif (*nData)[i].isOccupied {\n\t\t\ttable.Insert((*nData)[i].key, (*nData)[i].value)\n\t\t}\n\t}\n}\n\n// HashMap class END\n///---------------------------------------------------------------------------------------------------------\n\n\ntype MyHashMap struct {\n    m_hm HashMap\n}\n\nfunc hs(s interface{}) indexType {\n        \n        b := make([]byte, 8)\n    binary.LittleEndian.PutUint64(b, uint64(s.(int)))\n        h := fnv.New64()\n        h.Write([]byte(b))\n        return indexType(h.Sum64())\n}\n\n/** Initialize your data structure here. */\nfunc Constructor() MyHashMap {\n    var m MyHashMap\n    m.m_hm = CreateNewHashMap(0.7, 100, func(key interface{}) indexType {\n        return hs(key)\n    })\n    return m\n}\n\n\n/** value will always be non-negative. */\nfunc (this *MyHashMap) Put(key int, value int)  {\n    this.m_hm.Set(key, value)\n}\n\n\n/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\nfunc (this *MyHashMap) Get(key int) int {\n    exists, val := this.m_hm.GetVal(key)\n    if exists {\n        return val.(int)\n    }\n    return -1\n}\n\n\n/** Removes the mapping of the specified value key if this map contains a mapping for the key */\nfunc (this *MyHashMap) Remove(key int)  {\n    this.m_hm.Erase(key)\n}\n\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Put(key,value);\n * param_2 := obj.Get(key);\n * obj.Remove(key);\n */","compare_result":"111111111111111111111111111111111","title_slug":"design-hashmap"}