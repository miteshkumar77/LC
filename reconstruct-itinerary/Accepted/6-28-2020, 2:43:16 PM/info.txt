{"id":359497734,"lang":"cpp","time":"1 year, 9 months","timestamp":1593369796,"status_display":"Accepted","runtime":"44 ms","url":"/submissions/detail/359497734/","is_pending":"Not Pending","title":"Reconstruct Itinerary","memory":"15.3 MB","code":"class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        unordered_map<string, list<string>> graph; \n        stack<string> path; \n        \n\n        for (vector<string> tk : tickets) {\n            graph[tk[0]].push_back(tk[1]); \n        }\n        for (auto it = graph.begin(); it != graph.end(); ++it) {\n            (it -> second).sort();  \n        }\n        \n        dfs(graph, path, \"JFK\"); \n        vector<string> ans; \n        while(!path.empty()) {\n            ans.push_back(path.top()); path.pop(); \n        }\n        return ans; \n    }\n    \n    void dfs(unordered_map<string, list<string>>& graph, \n             stack<string>& path, string node) {\n        \n        if (graph.find(node) == graph.end() || \n            graph[node].size() == 0) {\n            path.push(node); \n            return; \n        }\n        \n        string neighbor; \n        while(graph[node].size() != 0) {\n            neighbor = *graph[node].begin(); \n            graph[node].pop_front(); \n            dfs(graph, path, neighbor); \n        }\n        \n        \n        path.push(node); \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reconstruct-itinerary"}