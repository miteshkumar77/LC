{"id":406583145,"lang":"cpp","time":"1 year, 6 months","timestamp":1602255622,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/406583145/","is_pending":"Not Pending","title":"Construct Binary Search Tree from Preorder Traversal","memory":"13 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n\n// [8, 5, 1]\n\nclass Solution {\npublic:\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if (preorder.size() == 0) {\n            return nullptr;\n        }\n        stack<TreeNode*> stk;\n        stk.push(new TreeNode(preorder[0]));\n        TreeNode* root = stk.top();\n        for (int i = 1; i < preorder.size(); ++i) {\n            if (stk.top() -> val > preorder[i]) {\n                stk.top() -> left = new TreeNode(preorder[i]);\n                stk.push(stk.top() -> left);\n            } else {\n                TreeNode* tmp = nullptr;\n                while(!stk.empty() && stk.top() -> val < preorder[i]) {\n                    tmp = stk.top();\n                    stk.pop();\n                }\n                tmp -> right = new TreeNode(preorder[i]);\n                stk.push(tmp -> right);\n            }\n        }\n        return root;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-search-tree-from-preorder-traversal"}