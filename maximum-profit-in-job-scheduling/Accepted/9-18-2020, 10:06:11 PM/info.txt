{"id":397673262,"lang":"cpp","time":"1 year, 7 months","timestamp":1600481171,"status_display":"Accepted","runtime":"220 ms","url":"/submissions/detail/397673262/","is_pending":"Not Pending","title":"Maximum Profit in Job Scheduling","memory":"47.4 MB","code":"class Solution {\n    \n    \nprivate:\n    struct Job {\n        \n        Job(int startTime, int endTime, int prof) {\n            start = startTime; \n            end = endTime; \n            profit = prof; \n        }\n        \n        bool operator < (const Job& j) const {\n            return this -> end < j.end; \n        }\n        \n        int start; \n        int end; \n        int profit; \n    };\n    \npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = profit.size(); \n        vector<Job> jobs; jobs.reserve(n);  \n        for (int i = 0; i < profit.size(); ++i) {\n            jobs.push_back(Job(startTime[i], endTime[i], profit[i])); \n        }\n        \n        sort(jobs.begin(), jobs.end()); \n        \n        vector<int> dp(n); \n        dp[0] = jobs[0].profit;\n        \n        for (int i = 1; i < n; ++i) {\n            int j = i - 1; \n            int prevprof = 0; \n            while(j >= 0 && jobs[j].end > jobs[i].start) {\n                --j; \n            }\n            if (j >= 0) {\n                prevprof = dp[j]; \n            }\n            dp[i] = max(dp[i - 1], prevprof + jobs[i].profit);\n        }\n        \n        return dp.back(); \n    }\n};","compare_result":"111111111111111111111111111","title_slug":"maximum-profit-in-job-scheduling"}