{"id":397674245,"lang":"cpp","time":"1 year, 7 months","timestamp":1600481433,"status_display":"Accepted","runtime":"228 ms","url":"/submissions/detail/397674245/","is_pending":"Not Pending","title":"Maximum Profit in Job Scheduling","memory":"47.3 MB","code":"class Solution {\n    \n    \nprivate:\n    struct Job {\n        \n        Job(int startTime, int endTime, int prof) {\n            start = startTime; \n            end = endTime; \n            profit = prof; \n        }\n        \n        bool operator < (const Job& j) const {\n            return this -> end < j.end; \n        }\n        \n        int start; \n        int end; \n        int profit; \n    };\n    \npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = profit.size(); \n        vector<Job> jobs; jobs.reserve(n);  \n        for (int i = 0; i < profit.size(); ++i) {\n            jobs.push_back(Job(startTime[i], endTime[i], profit[i])); \n        }\n        \n        sort(jobs.begin(), jobs.end()); \n        \n        vector<int> dp(n); \n        dp[0] = jobs[0].profit;\n        \n        for (int i = 1; i < n; ++i) {\n            int prevprof = 0; \n            int L = 0; \n            int R = i - 1; \n            \n            while(L <= R) {\n                int mid = L + (R - L)/2; \n                if (jobs[mid].end > jobs[i].start) {\n                    R = mid - 1; \n                } else {\n                    prevprof = dp[mid]; \n                    L = mid + 1; \n                }\n            }\n            \n            dp[i] = max(dp[i - 1], prevprof + jobs[i].profit);\n        }\n        \n        return dp.back(); \n    }\n};","compare_result":"111111111111111111111111111","title_slug":"maximum-profit-in-job-scheduling"}