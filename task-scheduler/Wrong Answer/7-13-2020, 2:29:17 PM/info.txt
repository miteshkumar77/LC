{"id":366140843,"lang":"cpp","time":"1 year, 9 months","timestamp":1594664957,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/366140843/","is_pending":"Not Pending","title":"Task Scheduler","memory":"N/A","code":"class Solution {\n    \n    \n    \nprivate: \n    \n    class HashQueue {\n     \n        \n    public: \n        \n        HashQueue(int historySize) {\n            n = historySize; \n            for (int i = 0; i < historySize; ++i) {\n                queue.push_back(nullChar); \n            }\n        }\n        \n        \n        void push(char task) {\n            \n            if (hash.find(task) != hash.end()) {\n                *(hash[task]) = nullChar; \n            }\n            \n            \n            queue.push_back(task); \n            hash[task] = prev(queue.end()); \n            if (queue.front() != nullChar) {\n                hash.erase(queue.front());\n            }\n            queue.pop_front(); \n            // cout << \"S: \" << this -> cooldownSize() << ' '; \n        }\n        \n        \n        bool contains(char task) {\n            return hash.find(task) != hash.end();  \n        }\n        \n        \n        \n        void pop() {\n            if (queue.size() != 0) {\n                if (queue.front() != nullChar) {\n                    hash.erase(queue.front()); \n                }\n                queue.push_back(nullChar); \n                queue.pop_front(); \n                 \n            }\n            // cout << \"S: \" << this -> cooldownSize() << ' '; \n        }\n        \n        \n        int cooldownSize() {\n            return hash.size(); \n        }\n        \n        \n    private: \n        \n        unordered_map<char, list<char>::iterator> hash; \n        list<char> queue; \n        int n; \n        char nullChar = '$'; \n        \n    };\n    \n    \n    \n    \n    \npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        if (n == 0) {\n            return tasks.size(); \n        }\n        unordered_map<char, int> task_cts; \n        int ans = 0; \n        for (char c : tasks) {\n            ++task_cts[c]; \n        }\n        \n        priority_queue<pair<int, char>, vector<pair<int, char>>, greater<pair<int, char>>> mq;\n        for (pair<char, int> p : task_cts) {\n            mq.push(make_pair(p.second, p.first)); \n        }\n        list<pair<int, char> > stak; \n        HashQueue hq(n); \n        \n        \n        while(!mq.empty()) {\n            \n            while(!mq.empty()) {\n                stak.push_back(mq.top()); mq.pop();  \n            }\n            // if (!mq.empty()) {\n            //     pair<int, char> t = mq.top(); mq.pop(); \n            //     --t.first; \n            //     hq.push(t.second); \n            //     if (t.first != 0) {\n            //         mq.push(t); \n            //     }\n            //     // cout << ' ' << t.second << \" | \";  \n            // } else {\n            //     hq.pop(); \n            //     // cout << \" idle | \"; \n            // }\n            \n            bool nothing = true;\n            while(stak.size() != 0) {\n                pair<int, char> t = stak.back();\n                stak.pop_back(); \n                if (!hq.contains(t.second)) {\n                    --t.first; \n                    hq.push(t.second); \n                    \n                    nothing = false; \n                    ++ans; \n                } \n                \n                if (t.first != 0) {\n                    mq.push(t); \n                }\n                \n                \n            }\n            if (nothing) {\n                hq.pop(); \n                ++ans; \n            }\n            \n        } \n\n        return ans; \n    }\n};","compare_result":"110111111111111110100110111000111100000000000000000000000000000000000","title_slug":"task-scheduler"}