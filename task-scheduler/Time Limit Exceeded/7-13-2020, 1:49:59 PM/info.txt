{"id":366126411,"lang":"cpp","time":"1 year, 9 months","timestamp":1594662599,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/366126411/","is_pending":"Not Pending","title":"Task Scheduler","memory":"N/A","code":"class Solution {\n    \n    \n    \nprivate: \n    \n    class HashQueue {\n     \n        \n    public: \n        \n        HashQueue(int historySize) {\n            n = historySize; \n            for (int i = 0; i < historySize; ++i) {\n                queue.push_back(nullChar); \n            }\n        }\n        \n        \n        void push(char task) {\n            \n            if (hash.find(task) != hash.end()) {\n                *(hash[task]) = nullChar; \n            }\n            \n            \n            queue.push_back(task); \n            hash[task] = prev(queue.end()); \n            if (queue.front() != nullChar) {\n                hash.erase(queue.front());\n            }\n            queue.pop_front(); \n            // cout << \"S: \" << this -> cooldownSize() << ' '; \n        }\n        \n        \n        bool contains(char task) {\n            return hash.find(task) != hash.end();  \n        }\n        \n        \n        \n        void pop() {\n            if (queue.size() != 0) {\n                if (queue.front() != nullChar) {\n                    hash.erase(queue.front()); \n                }\n                queue.push_back(nullChar); \n                queue.pop_front(); \n                 \n            }\n            // cout << \"S: \" << this -> cooldownSize() << ' '; \n        }\n        \n        \n        int cooldownSize() {\n            return hash.size(); \n        }\n        \n        \n    private: \n        \n        unordered_map<char, list<char>::iterator> hash; \n        list<char> queue; \n        int n; \n        char nullChar = '$'; \n        \n    };\n    \n    \n    \n    \n    \npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        if (n == 0) {\n            return tasks.size(); \n        }\n        unordered_map<char, int> task_cts; \n        int ans = 0; \n        for (char c : tasks) {\n            ++task_cts[c]; \n        }\n        \n        priority_queue<pair<int, char>, vector<pair<int, char>>, less<pair<int, char>>> mq;\n        for (pair<char, int> p : task_cts) {\n            mq.push(make_pair(p.second, p.first)); \n        }\n        list<pair<int, char> > stak; \n        HashQueue hq(n); \n        \n        \n        while(!mq.empty()) {\n            \n            while(!mq.empty() && hq.contains(mq.top().second)) {\n                stak.push_back(mq.top()); mq.pop();  \n            }\n            if (!mq.empty()) {\n                pair<int, char> t = mq.top(); mq.pop(); \n                --t.first; \n                hq.push(t.second); \n                if (t.first != 0) {\n                    mq.push(t); \n                }\n                // cout << ' ' << t.second << \" | \";  \n            } else {\n                hq.pop(); \n                // cout << \" idle | \"; \n            }\n            \n\n            while(stak.size() != 0) {\n                mq.push(stak.back()); \n                stak.pop_back(); \n            }\n            ++ans; \n            \n        } \n\n        return ans; \n    }\n};","compare_result":"111111111111111111111111111111111000000000000000000000000000000000000","title_slug":"task-scheduler"}