{"id":394883583,"lang":"cpp","time":"1 year, 7 months","timestamp":1599965960,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/394883583/","is_pending":"Not Pending","title":"Redundant Connection II","memory":"N/A","code":"class Solution {\npublic:\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n        \n        \n        int n = edges.size(); \n        \n        vector<vector<int>> graph(n + 1, vector<int>());\n        \n        \n        for (int e = 0; e < edges.size(); ++e) {\n            graph[edges[e][0]].push_back(edges[e][1]); \n        }\n        \n        int root = 0; \n        \n        \n        vector<int> numpaths(n + 1, 0); \n        \n        function<void(int)> dfs = [&](int node) -> void {\n            ++numpaths[node]; \n            if (numpaths[node] > 1) {\n                return; \n            }\n            \n            \n            for (int neighbor : graph[node]) {\n                dfs(neighbor); \n            }\n            root = node; \n        };\n        \n        \n        for (int i = 1; i <= n; ++i) {\n            dfs(i); \n        }\n        \n        numpaths = vector<int>(n + 1, 0); \n        dfs(root); \n        \n        vector<int> ans; \n        \n        for (auto edge : edges) {\n            if (numpaths[edge[1]] > 1) {\n                ans = edge; \n            }\n        }\n        return ans; \n    }\n};","compare_result":"1100101111111111110001110000111111111111111111111111","title_slug":"redundant-connection-ii"}