{"id":446425235,"lang":"cpp","time":"1 year, 2 months","timestamp":1611343864,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/446425235/","is_pending":"Not Pending","title":"Redundant Connection II","memory":"N/A","code":"class Solution {\npublic:\n    \n    int dfs(const vector<unordered_map<int,int>>& graph, vector<int>& visited, int node) {\n        if (visited[node] == 2) {\n            return -1;\n        }\n        if (visited[node] == 1) {\n            return 0;\n        }\n        ++visited[node];\n        int ans = -1;\n        int ret;\n        for (auto [neighbor, index] : graph[node]) {\n            ret = dfs(graph, visited, neighbor); \n            if (ret != -1) {\n                ans = max(ans, max(index, ret)); \n            }\n        }\n        ++visited[node];\n        return ans;\n    }\n    \n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n        int n = edges.size(); \n            \n        vector<unordered_map<int,int>> graph(n + 1);\n        vector<int> indegree(n + 1, 0);\n        vector<int> outdegree(n + 1, 0); \n        int zx = 0;\n        for (auto& e : edges) {\n            ++indegree[e[1]];\n            ++outdegree[e[0]];\n            graph[e[0]][e[1]] = zx;\n            ++zx;\n        }\n        \n        \n        for (auto& e : edges) {\n            if (indegree[e[1]] == 2 && indegree[e[0]] == 1) {\n                return e;\n            }\n        }\n        int ret;\n        vector<int> visited(n + 1, 0); \n        for (int i = 1; i <= n; ++i) {\n            ret = dfs(graph, visited, i);\n            if (ret != -1) {\n                return edges[ret];\n            }\n        }\n        return edges.back(); \n        \n    }\n};","compare_result":"111111001110000011101111111111001001100000100000000000","title_slug":"redundant-connection-ii"}