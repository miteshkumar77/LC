{"id":446042629,"lang":"cpp","time":"1 year, 2 months","timestamp":1611264290,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/446042629/","is_pending":"Not Pending","title":"Redundant Connection II","memory":"N/A","code":"class Solution {\npublic:\n    int cycleEdge(vector<unordered_map<int,int>>& graph, int root, vector<int>& visited) {\n        if (visited[root] == 1) {\n            return 0;\n        }\n        \n        if (visited[root] == 2) {\n            return -1;\n        }\n        \n        ++visited[root];\n        int ans = -1;\n        for (auto [neighbor, edgeIdx] : graph[root]) {\n            int ret = cycleEdge(graph, neighbor, visited); \n            if (ret != -1) {\n                ans = max(ans, max(ret, edgeIdx)); \n            }\n        }\n        ++visited[root];\n        return ans;\n    }\n    \n    void dfs(vector<unordered_map<int,int>>& graph, int root, vector<int>& visited) {\n        ++visited[root];\n        if (visited[root] > 1) return;\n        \n        for (auto [neighbor, edgeIdx] : graph[root]) {\n            dfs(graph, neighbor, visited);\n        }\n    }\n    \n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n        int n = edges.size();\n        vector<int> visited(n + 1, 0); \n        vector<int> indegree(n + 1, 0); \n        int root = 0;\n        vector<unordered_map<int,int>> graph(n + 1); \n        for (int i = 0; i < n; ++i) {\n            graph[edges[i][0]].insert({edges[i][1], i}); \n            ++indegree[edges[i][1]]; \n            if (indegree[edges[i][0]] == 0) {\n                root = edges[i][0];\n            }\n        }\n        \n        for (int i = 1; i <= n; ++i) {\n            int ans = cycleEdge(graph, i, visited); \n            if (ans != -1) {\n                return edges[ans];\n            }\n        }\n        \n        fill(visited.begin(), visited.end(), 0); \n        dfs(graph, root, visited); \n        \n        int extraNode = -1;\n        for (int i = 1; i <= n; ++i) {\n            if (visited[i] == 2) {\n                extraNode = i;\n                break;\n            }\n        }\n        \n        int edgeIdx = 0;\n        for (int i = 0; i < n; ++i) {\n            \n            if (edges[i][1] == extraNode) {\n                edgeIdx = i;\n            }\n        }\n        return edges[edgeIdx];\n        \n        \n    \n    }\n};","compare_result":"110110111111111111110000000000011110000010100000100100","title_slug":"redundant-connection-ii"}