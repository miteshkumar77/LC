{"id":407434129,"lang":"cpp","time":"1 year, 6 months","timestamp":1602439909,"status_display":"Accepted","runtime":"284 ms","url":"/submissions/detail/407434129/","is_pending":"Not Pending","title":"Web Crawler Multithreaded","memory":"41.9 MB","code":"/**\n * // This is the HtmlParser's API interface.\n * // You should not implement it, or speculate about its implementation\n * class HtmlParser {\n *   public:\n *     vector<string> getUrls(string url);\n * };\n */\n\n#define NUM_THREADS 5\nclass Solution {\nprivate:\n    mutex mtx_push;\n    mutex mtx_pop;\npublic:\n    \n    string hostName(string& s) {\n        int n = s.find('/', 7);\n        n = n == string::npos?s.length():n - 7;\n        return s.substr(7, n);\n    }\n    \n    vector<string> crawl(string startUrl, HtmlParser htmlParser) {\n        \n        unordered_set<string> visited;\n        queue<string> q;\n        \n        q.push(startUrl);\n        \n        string host = hostName(startUrl);\n        \n        function<void()> process = [&]() -> void {\n            while(true) { \n                mtx_pop.lock();\n                if (q.empty()) {\n                    mtx_pop.unlock();\n                    return;\n                }\n                string top = q.front();\n                q.pop();\n                \n                string topHostName = hostName(top);\n                \n                if (topHostName != host || visited.find(top) != visited.end()) {\n                    mtx_pop.unlock();\n                    continue;\n                }\n                visited.insert(top);\n                mtx_pop.unlock();\n                \n                \n                \n                \n                \n                vector<string> urls = htmlParser.getUrls(top);\n                for (string url : urls) {\n                    mtx_push.lock();\n                    q.push(url);\n                    mtx_push.unlock();\n                }\n                \n            }\n        };\n        \n        vector<thread> workers;\n        for (int i = 0; i < NUM_THREADS; ++i) {\n            workers.push_back(thread(process));\n        }\n        \n        for_each(workers.begin(), workers.end(), [](thread& t) {\n            t.join(); \n        });\n        \n        return vector<string>(visited.begin(), visited.end());\n        \n    }\n};","compare_result":"11111111111111111111","title_slug":"web-crawler-multithreaded"}