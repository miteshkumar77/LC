{"id":441763978,"lang":"cpp","time":"1 year, 3 months","timestamp":1610403971,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/441763978/","is_pending":"Not Pending","title":"Find Minimum Time to Finish All Jobs","memory":"N/A","code":"class Solution {\npublic:\n    int minimumTimeRequired(vector<int>& jobs, int k) {\n        int n = jobs.size();\n        vector<int> assigned(k, 0);\n        vector<int> subset(k, 0);\n        unordered_set<string> visited;\n        if (k == 1 || n == 1) {\n            return accumulate(jobs.begin(), jobs.end(), 0);\n        }\n        int min_max = max(*max_element(jobs.begin(), jobs.end()), accumulate(jobs.begin(), jobs.end(), 0)/2);\n        function<string()> getConjoined = [&]() -> string {\n            vector<int> cpy(subset.begin(), subset.end());\n            sort(cpy.begin(), cpy.end());\n            string ret;\n            for (int i : cpy) {\n                ret += to_string(i);\n                ret += \" \";\n            }\n            ret.pop_back();\n            return ret;\n        };\n        \n        \n        function<void(int)> bt = [&](int job) -> void {\n            \n            if (job >= n) {\n                min_max = min(min_max, *max_element(assigned.begin(), assigned.end()));\n                return;\n            }\n            \n            for (int worker = 0; worker < k; ++worker) {\n                assigned[worker] += jobs[job];\n                subset[worker] |= 1 << job;\n                if (visited.find(getConjoined()) == visited.end() && assigned[worker] < min_max) {\n                    visited.insert(getConjoined());\n                    bt(job + 1);\n                }\n                assigned[worker] -= jobs[job];\n                subset[worker] &= ~(1 << job);\n            }\n        };        \n        \n        bt(0);\n        return min_max;\n        \n    }\n};","compare_result":"11111111011101011111111110111101111101101100000000000000000","title_slug":"find-minimum-time-to-finish-all-jobs"}