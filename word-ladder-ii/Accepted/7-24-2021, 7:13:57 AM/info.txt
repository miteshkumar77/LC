{"id":527477786,"lang":"cpp","time":"8 months, 4 weeks","timestamp":1627125237,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/527477786/","is_pending":"Not Pending","title":"Word Ladder II","memory":"14.9 MB","code":"class Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        wordList.push_back(beginWord); \n        unordered_map<string, unordered_set<string>> pools; \n        for (string word : wordList) {\n            string s = word; \n            for (int i = 0; i < word.length(); ++i) {\n                s[i] = '*'; \n                pools[s].insert(word); \n                s[i] = word[i]; \n            }\n        }\n        \n        \n        unordered_map<string, vector<string>> graph; \n        unordered_map<string, int> dist; \n        \n        for (auto p : pools) {\n            vector<string> iterable(p.second.begin(), p.second.end()); \n            for (int i = 0; i < p.second.size(); ++i) {\n                for (int j = i + 1; j < p.second.size(); ++j) {\n                    graph[iterable[i]].push_back(iterable[j]); \n                    graph[iterable[j]].push_back(iterable[i]); \n                    \n                }\n            }\n        }\n        \n        for (string s : wordList) {\n            dist[s] = INT_MAX; \n        }\n        \n        queue<pair<string, int>> q; \n        q.push(make_pair(endWord, 0)); \n        \n        while(!q.empty()) {\n            string word = q.front().first; \n            int cdist = q.front().second; \n            q.pop(); \n            if (cdist < dist[word]) {\n                dist[word] = cdist; \n                if (word == beginWord) {\n                    break; \n                }\n                for (string neighbor : graph[word]) {\n                    q.push(make_pair(neighbor, cdist + 1)); \n                }\n            }\n        }\n        \n        // for (auto p : dist) {\n        //     cout << p.first << ' ' << p.second << endl; \n        // }\n        \n        if (dist[beginWord] == INT_MAX) {\n            return vector<vector<string>>(); \n        }\n        \n        vector<vector<string>> ans; \n        vector<string> box; \n        function<void(string&)> bt = [&](string& node) -> void {\n            box.push_back(node); \n            if (node == endWord) {\n                ans.push_back(box); \n                box.pop_back(); \n                return; \n            }    \n            \n            int mindist = INT_MAX; \n            for (string neighbor : graph[node]) {\n                mindist = min(mindist, dist[neighbor]); \n            }\n            \n            if (mindist == INT_MAX) {\n                box.pop_back(); \n                return;\n            }\n            for (string neighbor : graph[node]) {\n                if (dist[neighbor] == mindist) {\n                    bt(neighbor); \n                }\n            }\n            \n            box.pop_back(); \n        };\n            \n        bt(beginWord); \n        return ans; \n        \n    }\n};","compare_result":"11111111111111111111111111111111","title_slug":"word-ladder-ii"}