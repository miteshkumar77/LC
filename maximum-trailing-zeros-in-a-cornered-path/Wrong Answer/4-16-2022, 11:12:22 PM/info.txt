{"id":681881290,"lang":"cpp","time":"1 day, 20 hours","timestamp":1650165142,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/681881290/","is_pending":"Not Pending","title":"Maximum Trailing Zeros in a Cornered Path","memory":"N/A","code":"class Solution {\npublic:\n    \n    int intlog(int base, int x) {\n        int ans{0};\n        while(x % base == 0) {\n            x /= base;\n            ++ans;\n        }\n        return ans;\n    } \n    \n    int maxTrailingZeros(vector<vector<int>>& grid) {\n        int n = grid.size(); int m = grid[0].size();    \n        vector<vector<array<int,2>>> up(n+2, vector<array<int,2>>(m+2, {0, 0}));\n        vector<vector<array<int,2>>> dn(n+2, vector<array<int,2>>(m+2, {0, 0}));\n        vector<vector<array<int,2>>> le(n+2, vector<array<int,2>>(m+2, {0, 0}));\n        vector<vector<array<int,2>>> ri(n+2, vector<array<int,2>>(m+2, {0, 0}));\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                int nf = (grid[i-1][j-1] % 5 == 0) ? intlog(5, grid[i-1][j-1]) : 0;\n                int nt = (grid[i-1][j-1] % 2 == 0) ? intlog(2, grid[i-1][j-1]) : 0;\n                up[i][j] = {up[i-1][j][0] + nf, up[i-1][j][1] + nt};\n                le[i][j] = {le[i][j-1][0] + nf, le[i][j-1][1] + nt};\n            }\n        }\n        for (int i = n; i >= 1; --i) {\n            for (int j = m; j >= 1; --j) {\n                int nf = (grid[i-1][j-1] % 5 == 0) ? intlog(5, grid[i-1][j-1]) : 0;\n                int nt = (grid[i-1][j-1] % 2 == 0) ? intlog(2, grid[i-1][j-1]) : 0;\n                dn[i][j] = {dn[i+1][j][0] + nf, dn[i+1][j][1] + nt};\n                ri[i][j] = {ri[i][j+1][0] + nf, ri[i][j+1][1] + nt};\n            }\n        }\n        int ans{0};\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                int nf = (grid[i-1][j-1] % 5 == 0) ? intlog(5, grid[i-1][j-1]) : 0;\n                int nt = (grid[i-1][j-1] % 2 == 0) ? intlog(2, grid[i-1][j-1]) : 0;\n                int amt1 = min(up[i][j][0] + le[i][j][0] - nf, up[i][j][1] + le[i][j][1] - nt);\n                int amt2 = min(up[i][j][0] + ri[i][j][0] - nf, up[i][j][1] + ri[i][j][1] - nt);\n                int amt3 = min(dn[i][j][0] + ri[i][j][0] - nf, up[i][j][1] + ri[i][j][1] - nt);\n                int amt4 = min(dn[i][j][0] + le[i][j][0] - nf, dn[i][j][1] + le[i][j][1] - nt);\n                int amt = max(amt1, max(amt2, max(amt3, amt4)));\n                ans = max(ans, amt);\n            }\n        }\n        return ans;\n    }\n};","compare_result":"111111111111111101111111111111110111111111111111111111","title_slug":"maximum-trailing-zeros-in-a-cornered-path"}