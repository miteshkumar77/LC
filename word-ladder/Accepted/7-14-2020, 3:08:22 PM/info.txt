{"id":366617689,"lang":"cpp","time":"1 year, 9 months","timestamp":1594753702,"status_display":"Accepted","runtime":"384 ms","url":"/submissions/detail/366617689/","is_pending":"Not Pending","title":"Word Ladder","memory":"49.3 MB","code":"class Solution {\npublic:\n    typedef pair<string, int> psi; \n    \n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        \n        unordered_map<string, unordered_set<string> > graph; \n        unordered_map<string, list<string> > rgraph; \n        unordered_set<string> visited; \n        \n        // Preprocess\n        wordList.push_back(beginWord); \n        for (string s : wordList) {\n            // cout << s << \": \"; \n            for (int i = 0; i < s.length(); ++i) {\n                \n                string q = s; \n                q[i] = '*'; \n                // cout << q << ' '; \n                rgraph[q].push_back(s); \n            } \n        } \n        // cout << endl; \n        // Construct graph\n        for (auto collection : rgraph) {\n            for (auto it1 = collection.second.begin(); \n                 it1 != collection.second.end(); ++it1) {\n                string s1 = *it1; \n                for (auto it2 = next(it1); \n                    it2 != collection.second.end(); ++it2) {\n                    string s2 = *it2; \n                    // cout << s1 << ' ' << s2 << endl; \n                    graph[s1].insert(s2); \n                    graph[s2].insert(s1); \n                } \n            }\n        }\n        \n        \n//         for (auto collection : graph) {\n//             cout << collection.first << \": \"; \n//             for (string s : collection.second) {\n                // cout << s << ' '; \n//             }cout << endl; \n//         }\n        \n        \n        queue<psi> q; \n        q.push(psi(beginWord, 1));\n        visited.insert(beginWord); \n        while(!q.empty()) {\n            psi top = q.front(); q.pop(); \n            // cout << top.first << ' ' << top.second << endl; \n\n            for (string w : graph[top.first]) {\n                if (visited.find(w) == visited.end()) {\n                    if (w == endWord) {\n                        return top.second + 1; \n                    }\n                    q.push(psi(w, top.second + 1));\n                    visited.insert(w); \n                }\n            }\n        }\n        return 0; \n        \n    }\n};","compare_result":"1111111111111111111111111111111111111111111","title_slug":"word-ladder"}