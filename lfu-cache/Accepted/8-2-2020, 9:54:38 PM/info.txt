{"id":375203766,"lang":"cpp","time":"1 year, 8 months","timestamp":1596419678,"status_display":"Accepted","runtime":"200 ms","url":"/submissions/detail/375203766/","is_pending":"Not Pending","title":"LFU Cache","memory":"43 MB","code":"#include<bits/stdc++.h>\n\nusing namespace std; \n\n\nclass LFUCache {\n    \nstruct mapNode {\n    int val; \n    list<pair<int, list<int>>>::iterator level_it; \n    list<int>::iterator sub_level_it; \n    \n    mapNode() {\n        \n    }\n\n    mapNode(int v) {\n        val = v;\n    }\n};\n    \n    \n    \n    void printDeck() {\n        for (auto it : lfreq) {\n            cout << it.first << \": \";\n            for (auto it2 : it.second) {\n                cout << it2 << ' '; \n            }cout << endl; \n        }\n    }\npublic:\n    LFUCache(int capacity) {\n        n = capacity; \n    }\n    \n    int get(int key) {\n        if (n == 0) {\n            return -1; \n        }\n        // cout << \"GET: \" << key << endl; \n        auto it = lmap.find(key); \n        if (it == lmap.end()) {\n            // cout << -1 << endl; \n            return -1; \n        }\n        \n        auto cur_lvl_it = (it -> second).second.level_it; \n        // cout << cur_lvl_it -> first << ' '; \n        auto cur_sub_lvl_it = (it -> second).second.sub_level_it; \n        // cout << (*cur_sub_lvl_it) << ' '; \n        (cur_lvl_it -> second).erase(cur_sub_lvl_it); \n        if (cur_lvl_it == lfreq.begin() || prev(cur_lvl_it) -> first > cur_lvl_it -> first + 1) {\n            lfreq.insert(cur_lvl_it, make_pair(cur_lvl_it -> first + 1, list<int>{key})); \n        } else {\n            (prev(cur_lvl_it) -> second).push_front(key); \n        }\n        \n        \n        lmap[key].second.level_it = prev(cur_lvl_it); \n        lmap[key].second.sub_level_it = (prev(cur_lvl_it) -> second).begin(); \n        // cout << lmap[key].second.level_it -> first << ' '; \n        // cout << (*lmap[key].second.sub_level_it) << ' '; \n\n        if ((cur_lvl_it -> second).size() == 0) {\n            lfreq.erase(cur_lvl_it); \n        }\n        \n        // printDeck(); \n        // cout << lmap[key].first << endl; \n        return lmap[key].first; \n        \n        \n    }\n    \n    void put(int key, int value) {\n        // cout <<\"PUT: \" << key << ' ' << value << endl; \n        if (n == 0) {\n            return; \n        }\n        if (lmap.find(key) == lmap.end()) {\n            if (lmap.size() >= n) {\n            \n                int del = lfreq.back().second.back(); \n                // cout << \"DELETED: \" << del << endl; \n                lfreq.back().second.pop_back(); \n\n                if (lfreq.back().second.size() == 0) {\n                    lfreq.pop_back(); \n                }\n\n                lmap.erase(del); \n            }\n            \n            if (lfreq.back().first != 1) {\n                lfreq.push_back(make_pair(1, list<int>())); \n            }\n\n            lfreq.back().second.push_front(key);\n            \n            mapNode tmp(key); \n            tmp.level_it = prev(lfreq.end());\n            tmp.sub_level_it = lfreq.back().second.begin(); \n            lmap[key] = make_pair(value, tmp); \n        } else {\n            lmap[key].first = value; \n            get(key); \n        }\n        \n        \n        // printDeck(); \n    }\nprivate:\n    int n; \n    list<pair<int, list<int>>> lfreq; \n    unordered_map<int, pair<int, mapNode>> lmap; \n};\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n// [\"LFUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\",\"put\",\"get\",\"get\",\"get\"]\n// [[2],[1,1],[2,2],[1],[3,3],[2],[3],[4,4],[1],[3],[4]]","compare_result":"11111111111111111111111","title_slug":"lfu-cache"}