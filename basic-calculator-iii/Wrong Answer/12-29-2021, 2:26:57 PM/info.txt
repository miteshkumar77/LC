{"id":609310650,"lang":"cpp","time":"3 months, 2 weeks","timestamp":1640806017,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/609310650/","is_pending":"Not Pending","title":"Basic Calculator III","memory":"N/A","code":"using namespace std;\nclass Solution {\npublic:\n    enum Token_t { NUM, ADD, SUB, MUL, DIV, LP, RP };\n    struct Token {\n        Token(Token_t t): t(t), val(0) {}\n        Token_t t;\n        int   val;\n    };\n\n\n    vector<Token> tokens;\n    int token_ptr{0};\n    \n    inline void print_tok(Token const& t) {\n        switch(t.t) {\n            case ADD:\n                cout << \"ADD\";\n                break;\n            case SUB:\n                cout << \"SUB\";\n                break;\n            case MUL:\n                cout << \"MUL\";\n                break;\n            case DIV:\n                cout << \"DIV\";\n                break;\n            case LP:\n                cout << \"LP\";\n                break;\n            case RP:\n                cout << \"RP\";\n                break;\n            case NUM:\n                cout << \"NUM(\" << t.val << \")\";\n                break;\n        }\n    }\n\n    void lex(string const& s) {\n        for (char c : s) {\n            if (isdigit(c)) {\n                if (tokens.empty() || tokens.back().t != NUM) {\n                    tokens.emplace_back(NUM);\n                }\n                tokens.back().val *= 10;\n                tokens.back().val += (c-'0');\n            } else if (c == ' ') {\n                continue;\n            } else if (c == '+') {\n                tokens.emplace_back(ADD);\n            } else if (c == '-') {\n                tokens.emplace_back(SUB);\n            } else if (c == '*') {\n                tokens.emplace_back(MUL);\n            } else if (c == '/') {\n                tokens.emplace_back(DIV);\n            } else if (c == '(') {\n                tokens.emplace_back(LP);\n            } else if (c == ')') {\n                tokens.emplace_back(RP);\n            }\n        }\n    }\n\n    inline bool term(Token_t t, int& ans) {\n        if (token_ptr >= tokens.size()) return false;\n        ans = tokens.at(token_ptr).val;\n        return tokens.at(token_ptr++).t == t;\n    }\n\n    inline bool term(Token_t t) {\n        if (token_ptr >= tokens.size()) return false;\n        return tokens.at(token_ptr++).t == t;\n    }\n\n    bool parse_Expr(int& ans) {\n        int save = token_ptr;\n        return parse_Expr1(ans)\n            || (token_ptr = save, parse_Expr2(ans))\n            || (token_ptr = save, parse_Expr3(ans));\n    }\n\n    bool parse_Expr1(int& ans) {\n        int lans;\n        int rans;\n        if (parse_Expr_p(lans) && term(ADD) && parse_Expr(rans)) {\n            ans = lans + rans;\n            return true;\n        }\n        return false;\n    }\n    \n    bool parse_Expr2(int& ans) {\n        int lans;\n        int rans;\n        if (parse_Expr_p(lans) && term(SUB) && parse_Expr(rans)) {\n            ans = lans - rans;\n            return true;\n        }\n        return false;\n    }\n\n    bool parse_Expr3(int& ans) {\n        return parse_Expr_p(ans);\n    }\n\n    bool parse_Expr_p(int& ans) {\n        int save = token_ptr;\n        return parse_Expr_p1(ans)\n            || (token_ptr = save, parse_Expr_p2(ans))\n            || (token_ptr = save, parse_Expr_p3(ans));\n    }\n\n    bool parse_Expr_p1(int& ans) {\n        int lans;\n        int rans;\n        if (parse_Expr_p_p(lans) && term(MUL) && parse_Expr_p(rans)) {\n            ans = lans * rans;\n            return true;\n        }\n        return false;\n    }\n\n    bool parse_Expr_p2(int& ans) {\n        int lans;\n        int rans;\n        if (parse_Expr_p_p(lans) && term(DIV) && parse_Expr_p(rans)) {\n            ans = lans / rans;\n            return true;\n        }\n        return false;\n    }\n\n    bool parse_Expr_p3(int& ans) {\n        return parse_Expr_p_p(ans);\n    }\n\n    bool parse_Expr_p_p(int& ans) {\n        int save = token_ptr;\n        return parse_Expr_p_p1(ans)\n            || (token_ptr = save, parse_Expr_p_p2(ans));\n    }\n\n    bool parse_Expr_p_p1(int& ans) {\n        return term(NUM, ans);\n    }\n\n    bool parse_Expr_p_p2(int& ans) {\n        return term(LP) && parse_Expr(ans) && term(RP);\n    }\n\n    \n    int calculate(string s) {\n        lex(s);\n        int ans;\n        parse_Expr(ans);\n        return ans;\n    }\n};","compare_result":"111111100000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"basic-calculator-iii"}