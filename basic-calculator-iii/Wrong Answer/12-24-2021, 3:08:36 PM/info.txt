{"id":606611071,"lang":"cpp","time":"3 months, 3 weeks","timestamp":1640376516,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/606611071/","is_pending":"Not Pending","title":"Basic Calculator III","memory":"N/A","code":"class Solution {\npublic:\n    enum Expr_t { Op, Term };\n    enum Token_t { Add, Sub, Mul, Div, LPar, RPar, Val };\n    struct Expr {\n        Expr_t t;    \n        \n        // t == Op\n        Expr* left;\n        string op;\n        Expr* right;\n        \n        // t ==  Term\n        int val;\n    };\n    \n    struct Token {\n        Token(Token_t t, string val): t(t), val(val) {}\n        Token_t t;\n        string val;\n    };\n    \n    Expr* make_Op(Expr* left, string op, Expr* right) {\n        Expr* e = new Expr();\n        e->t = Expr_t::Op;\n        e->left = left;\n        e->op = op;\n        e->right = right;\n        return e;\n    }\n    \n    Expr* make_Term(int val) {\n        Expr* e = new Expr();\n        e->t = Expr_t::Term;\n        e->val = val;\n        return e;\n    }\n    \n    vector<Token> lex(string const& s) {\n        vector<Token> ret;\n        for (char c : s) {\n            switch (c) {\n                case '+': ret.push_back(Token(Token_t::Add, \"+\")); break;\n                case '-': ret.push_back(Token(Token_t::Sub, \"-\")); break;\n                case '*': ret.push_back(Token(Token_t::Mul, \"*\")); break;\n                case '/': ret.push_back(Token(Token_t::Div, \"/\")); break;\n                case '(': ret.push_back(Token(Token_t::LPar, \"(\")); break;\n                case ')': ret.push_back(Token(Token_t::RPar, \")\")); break;\n                default:\n                    if (ret.size() == 0 || ret.back().t != Token_t::Val) {\n                        ret.push_back(Token(Token_t::Val, \"\"));\n                    }\n                    ret.back().val.push_back(c);\n                    break;\n            }\n        }\n        return ret;\n    }\n    \n    pair<Expr*, int> parse(vector<Token> & tokens, int i) {\n        vector<Expr*> expr_stk;\n        vector<Token> op_stk;\n        for (; i < tokens.size(); ++i) {\n            if (tokens[i].t == Token_t::Add ||\n                tokens[i].t == Token_t::Sub ||\n                tokens[i].t == Token_t::Mul ||\n                tokens[i].t == Token_t::Div) {\n                op_stk.push_back(tokens[i]);\n            } else if (tokens[i].t == Token_t::LPar) {\n                auto r = parse(tokens, i+1);\n                i = r.second;\n                expr_stk.push_back(r.first);\n            } else if (tokens[i].t == Token_t::RPar) {\n                break;\n            } else if (tokens[i].t == Token_t::Val) {\n                expr_stk.push_back(make_Term(stoi(tokens[i].val)));\n                if (expr_stk.size() == 3) {\n                    Expr* ret_expr;\n                    if ((op_stk[0].t == Token_t::Add || op_stk[0].t == Token_t::Sub) &&\n                        (op_stk[1].t == Token_t::Mul || op_stk[1].t == Token_t::Div)) {\n                        ret_expr = make_Op(\n                            expr_stk[0], op_stk[0].val, \n                            make_Op(expr_stk[1], op_stk[1].val, expr_stk[2]));\n                    } else {\n                        \n                        ret_expr = make_Op(\n                            make_Op(expr_stk[0], op_stk[0].val, expr_stk[1]), op_stk[1].val, expr_stk[2]);\n                    }\n                    expr_stk = vector<Expr*>{ret_expr};\n                    op_stk = vector<Token>{};\n                }\n            }\n        }\n        if (expr_stk.size() == 2) {\n            Expr* ret_expr = make_Op(expr_stk[0], op_stk[0].val, expr_stk[1]);\n            expr_stk = vector<Expr*>{ret_expr};\n        }\n        return {expr_stk[0], i};\n    }\n    \n    string print_tree(Expr* e) {\n        if (e->t == Expr_t::Term) {\n            return to_string(e->val);\n        } else {\n            return \"(\"+print_tree(e->left)+e->op+print_tree(e->right) + \")\";\n        }\n    }\n    \n    int eval(Expr* e) {\n        if (e->t == Expr_t::Term) {\n            return e->val;\n        } else {\n            auto l = eval(e->left);\n            auto r = eval(e->right);\n            if (e->op == \"+\") {\n                return l+r;\n            } else if (e->op == \"-\") {\n                return l-r;\n            } else if (e->op == \"*\") {\n                return l*r;\n            } else {\n                return l/r;\n            }\n        }\n    }\n    int calculate(string s) {\n        auto tokens = lex(s);\n        \n        Expr* e = parse(tokens, 0).first;\n        // cout << print_tree(e) << endl;\n        return eval(e);\n    }\n};","compare_result":"111011101011111111111111111110111001100001111111111111111111111111111111111111","title_slug":"basic-calculator-iii"}