{"id":403359011,"lang":"cpp","time":"1 year, 6 months","timestamp":1601610534,"status_display":"Accepted","runtime":"308 ms","url":"/submissions/detail/403359011/","is_pending":"Not Pending","title":"Frog Jump","memory":"42.8 MB","code":"class Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        unordered_map<int, unordered_set<int>> dp; \n        dp[stones[0]].insert(0);\n        \n        \n        for (int stone : stones) {\n            if (dp.find(stone) != dp.end()) {\n                for (int lastJump : dp[stone]) {\n                    int nextStonePlus = lastJump + 1 + stone;\n                    int nextStoneMinus = lastJump - 1 + stone;\n                    int nextStoneNeutral = lastJump + stone;\n                    dp[nextStonePlus].insert(lastJump + 1);\n                    if (lastJump > 1) {\n                        dp[nextStoneMinus].insert(lastJump - 1);\n                    }\n                    dp[nextStoneNeutral].insert(lastJump);\n                }\n            }\n        }\n        \n//         for (int i : stones) {\n//             cout << i << \": \";\n//             if (dp.find(i) != dp.end()) {\n//                 for (int st : dp[i]) cout << st << ' ';\n//             }\n//             cout << endl;\n\n//         }\n        \n        return dp.find(stones.back()) != dp.end();\n        \n    }\n};","compare_result":"111111111111111111111111111111111111111","title_slug":"frog-jump"}