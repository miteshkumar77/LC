{"id":403358444,"lang":"cpp","time":"1 year, 6 months","timestamp":1601610440,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/403358444/","is_pending":"Not Pending","title":"Frog Jump","memory":"N/A","code":"class Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        unordered_map<int, unordered_set<int>> dp; \n        dp[stones[0]].insert(1);\n        \n        \n        for (int stone : stones) {\n            if (dp.find(stone) != dp.end()) {\n                for (int lastJump : dp[stone]) {\n                    int nextStonePlus = lastJump + 1 + stone;\n                    int nextStoneMinus = lastJump - 1 + stone;\n                    int nextStoneNeutral = lastJump + stone;\n                    dp[nextStonePlus].insert(lastJump + 1);\n                    dp[nextStoneMinus].insert(lastJump - 1);\n                    dp[nextStoneNeutral].insert(lastJump);\n                }\n            }\n        }\n        \n//         for (int i : stones) {\n//             cout << i << \": \";\n//             if (dp.find(i) != dp.end()) {\n//                 for (int st : dp[i]) cout << st << ' ';\n//             }\n//             cout << endl;\n\n//         }\n        \n        return dp.find(stones.back()) != dp.end();\n        \n    }\n};","compare_result":"111101111111111111111111111111111111111","title_slug":"frog-jump"}