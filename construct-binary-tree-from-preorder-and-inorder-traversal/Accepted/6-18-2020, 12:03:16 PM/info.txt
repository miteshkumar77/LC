{"id":355382474,"lang":"cpp","time":"1 year, 10 months","timestamp":1592496196,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/355382474/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"21.7 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (preorder.size() == 0) {\n            return nullptr; \n        }\n        unordered_map <int, int> idx; \n        for (int i = 0; i < inorder.size(); ++i) {\n            idx[inorder[i]] = i; \n        }\n        TreeNode* root = new TreeNode(preorder[0]); \n        builder(root, nullptr, preorder, 1, idx);\n        return root; \n    }\n    \n    int builder(TreeNode* root, TreeNode* max, vector<int>& preorder, int i, unordered_map<int, int>& idx) {\n        if (i >= preorder.size()) {\n            return -1; \n        }\n        \n        int res = -1; \n        \n        if (idx[preorder[i]] < idx[root -> val]) {\n            root -> left = new TreeNode(preorder[i]); \n            res = builder(root -> left, root, preorder, i + 1, idx); \n        } else if (!max || idx[preorder[i]] < idx[max -> val]) {\n            root -> right = new TreeNode(preorder[i]); \n            res = builder(root -> right, max, preorder, i + 1, idx); \n        } else {\n            return i; \n        }\n        \n        if (res != -1) {\n            if (!max || idx[preorder[res]] < idx[max -> val]) {\n                root -> right = new TreeNode(preorder[res]); \n                res = builder(root -> right, max, preorder, res + 1, idx); \n            }\n        }\n        \n        return res; \n        \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}