{"id":372421657,"lang":"cpp","time":"1 year, 8 months","timestamp":1595879008,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/372421657/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"25.6 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        int n = inorder.size(); \n        if (n == 0) {\n            return nullptr; \n        }\n        unordered_map<int, int> gt; \n        for (int i = 1; i <= n; ++i) {\n            gt[inorder[i - 1]] = i;\n        }\n        \n        \n        \n        function<int(TreeNode*, TreeNode*, int)> builder = \n            [&] (TreeNode* min, TreeNode* mid, int i) -> int {\n            if (i <= -1) {\n                return -1; \n            }\n            int newVal = postorder[i]; \n            cout << i << endl; \n            int retIdx; \n            if (gt[newVal] > gt[mid -> val]) {\n                mid -> right = new TreeNode(newVal);\n                retIdx = builder(mid, mid -> right, i - 1); \n            } else {\n                if (!min || gt[newVal] > gt[min -> val]) {\n                    mid -> left = new TreeNode(newVal);\n                    retIdx = builder(min, mid -> left, i - 1);\n                } else {\n                    return i; \n                }\n            }\n            \n            if (retIdx > -1) {\n                int retVal = postorder[retIdx]; \n\n                if (!min || gt[retVal] > gt[min -> val]) {\n                    mid -> left = new TreeNode(retVal);\n                    return builder(min, mid -> left, retIdx - 1);\n                } else {\n                    return retIdx; \n                }\n            } else {\n                return -1; \n            }\n            \n            \n        };\n        \n        \n        \n        TreeNode* root = new TreeNode(postorder[n - 1]);\n        builder(nullptr, root, n - 2); \n        return root; \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal"}