{"id":535345555,"lang":"cpp","time":"8 months, 1 week","timestamp":1628444998,"status_display":"Accepted","runtime":"960 ms","url":"/submissions/detail/535345555/","is_pending":"Not Pending","title":"Rank Transform of a Matrix","memory":"59.5 MB","code":"class Solution {\npublic:\n    vector<int> parent;\n    vector<int> rank;\n    int find(int node) {\n        if (parent[node] == node) return node;\n        parent[node] = find(parent[node]);\n        return parent[node];\n    }\n    \n    void onion(int a, int b) {\n        int pa = find(a); int pb = find(b);\n        if (pa == pb) return;\n        parent[pa] = pb;\n    }\n    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {\n        int n = matrix.size(); int m = matrix[0].size();\n        int N = n * m;\n        cout << N << endl;\n        parent = vector<int>(N, -1);\n        rank = vector<int>(N, -1);\n        for (int i = 0; i < N; ++i) parent[i] = i;\n        vector<unordered_map<int,int>> r(n);\n        vector<unordered_map<int,int>> c(m);\n        vector<int> nodes(N); for (int i = 0; i < nodes.size(); ++i) nodes[i] = i;\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!r[i].count(matrix[i][j])) {\n                    r[i][matrix[i][j]] = i * m + j;\n                } else {\n                    onion(r[i][matrix[i][j]], i * m + j);\n                }\n                if (!c[j].count(matrix[i][j])) {\n                    c[j][matrix[i][j]] = i * m + j;\n                } else {\n                    onion(c[j][matrix[i][j]], i * m + j);\n                }\n            }\n        }\n        for (int i : nodes) find(i);\n        sort(nodes.begin(), nodes.end(), [&](int a, int b) {\n            return matrix[parent[a]/m][parent[a]%m] < matrix[parent[b]/m][parent[b]%m] || \n                   (matrix[parent[a]/m][parent[a]%m] == matrix[parent[b]/m][parent[b]%m] && parent[a] < parent[b]);\n        });\n        int prev = 0;\n        vector<int> lowest_r(n, 0);\n        vector<int> lowest_c(m, 0);\n        rank[find(nodes[0])] = 1;\n        int iters = 0;\n        for (int i = 1; i <= N; ++i) {\n            ++iters;\n            if (i == N || parent[nodes[i]] != parent[nodes[i-1]]) {\n                for (int j = prev; j < i; ++j) {\n                    ++iters;\n                    lowest_r[nodes[j]/m] = max(lowest_r[nodes[j]/m], rank[parent[nodes[j]]]);\n                    lowest_c[nodes[j]%m] = max(lowest_c[nodes[j]%m], rank[parent[nodes[j]]]);\n                }\n                prev = i;\n            }\n            if (i < N)\n                rank[parent[nodes[i]]] = max(rank[parent[nodes[i]]], max(lowest_r[nodes[i]/m], lowest_c[nodes[i]%m]) + 1);\n        }\n        cout << iters << endl;\n        for (int i : nodes) {\n            matrix[i/m][i%m] = rank[parent[i]];\n        }\n        return matrix;\n    }\n};","compare_result":"111111111111111111111111111111111111111","title_slug":"rank-transform-of-a-matrix"}