{"id":343690905,"lang":"cpp","time":"1 year, 11 months","timestamp":1590274641,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/343690905/","is_pending":"Not Pending","title":"Unique Binary Search Trees II","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        vector<vector<vector<TreeNode*> > > dp(n + 2, vector<vector<TreeNode*> >(n + 2, vector<TreeNode*>())); \n        return treeGenerator(1, n, dp); \n    }\n    \n    vector<TreeNode*> treeGenerator(int L, int R, vector<vector<vector<TreeNode*> > >& dp) {\n        \n        \n        if (dp[L][R].size() != 0) {\n            return dp[L][R]; \n        }\n        \n        if (R < L) {\n            dp[L][R] = vector<TreeNode*>{nullptr}; \n            return dp[L][R]; \n        }\n        if (L == R) {\n            dp[L][R] = vector<TreeNode*>{new TreeNode(L)}; \n            return dp[L][R];\n        }\n        vector<TreeNode*> res; \n        for (int i = L; i <= R; ++i) {\n            vector<TreeNode*> left_trees = treeGenerator(L, i - 1, dp); \n            vector<TreeNode*> right_trees = treeGenerator(i + 1, R, dp); \n            \n            for (int x = 0; x < left_trees.size(); ++x) {\n                for (int j = 0; j < right_trees.size(); ++j) {\n                    TreeNode* root = new TreeNode(i); \n                    root -> left = cpyTree(left_trees[x]);\n                    root -> right = cpyTree(right_trees[j]); \n                    res.push_back(root); \n                }\n            }\n        }\n        \n        dp[L][R] = res; \n        return res; \n    }\n    \n    TreeNode* cpyTree(TreeNode* root) {\n        if (!root) {\n            return nullptr; \n        }\n        \n        TreeNode* newRoot = new TreeNode(root -> val); \n        newRoot -> left = cpyTree(root -> left); \n        newRoot -> right = cpyTree(root -> right); \n        return newRoot; \n    }\n};","compare_result":"101111111","title_slug":"unique-binary-search-trees-ii"}