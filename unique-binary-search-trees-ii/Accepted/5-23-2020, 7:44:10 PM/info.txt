{"id":343706774,"lang":"cpp","time":"1 year, 10 months","timestamp":1590277450,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/343706774/","is_pending":"Not Pending","title":"Unique Binary Search Trees II","memory":"9.8 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        if (n == 0) {\n            return vector<TreeNode*>(); \n        }\n        vector<vector<vector<TreeNode*> > > dp(n + 2, vector<vector<TreeNode*> >(n + 2, vector<TreeNode*>())); \n        return treeGenerator(1, n, dp); \n    }\n    \n    vector<TreeNode*> treeGenerator(int L, int R, vector<vector<vector<TreeNode*> > >& dp) {\n        \n        \n        if (dp[L][R].size() != 0) {\n            return dp[L][R]; \n        }\n        \n        if (R < L) {\n            dp[L][R].push_back(nullptr);\n            return dp[L][R]; \n        }\n        if (L == R) {\n            dp[L][R].push_back(new TreeNode(L)); \n            return dp[L][R];\n        }\n        vector<TreeNode*> res; \n        for (int i = L; i <= R; ++i) {\n            vector<TreeNode*> left_trees = treeGenerator(L, i - 1, dp); \n            vector<TreeNode*> right_trees = treeGenerator(i + 1, R, dp); \n            \n            for (int x = 0; x < left_trees.size(); ++x) {\n                for (int j = 0; j < right_trees.size(); ++j) {\n                    TreeNode* root = new TreeNode(i); \n                    root -> left = left_trees[x];\n                    root -> right = right_trees[j]; \n                    dp[L][R].push_back(root); \n                }\n            }\n        }\n        \n        return dp[L][R]; \n    }\n    \n    TreeNode* cpyTree(TreeNode* root) {\n        if (!root) {\n            return nullptr; \n        }\n        \n        TreeNode* newRoot = new TreeNode(root -> val); \n        newRoot -> left = cpyTree(root -> left); \n        newRoot -> right = cpyTree(root -> right); \n        return newRoot; \n    }\n};","compare_result":"111111111","title_slug":"unique-binary-search-trees-ii"}