{"id":386921244,"lang":"cpp","time":"1 year, 7 months","timestamp":1598496551,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/386921244/","is_pending":"Not Pending","title":"Critical Connections in a Network","memory":"N/A","code":"class Solution {\npublic:\n    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\n        vector<int> parent1(n, -1); \n        function<int(int,vector<int>&)> find = [&](int node, vector<int>& parent) -> int {\n            if (parent[node] == -1) {\n                return node; \n            }\n            \n            parent[node] = find(parent[node], parent); \n            return parent[node]; \n        };\n        \n        function<bool(int,int,vector<int>&)> onion = [&](int n1, int n2, vector<int>& parent) -> bool {\n            if (find(n1, parent) == find(n2, parent)) {\n                return false; \n            }\n            \n            parent[n1] = n2; \n            find(n1, parent); \n            return true; \n        };\n        \n        \n        vector<vector<int>> treeEdges;\n        \n        for (auto connection: connections) {\n            if (onion(connection[0], connection[1], parent1)) {\n                treeEdges.push_back(connection); \n            }\n        }\n        \n        \n        unordered_map<int, unordered_set<int>> graph; \n        \n        for (auto connection: connections) {\n            graph.insert(make_pair(connection[0], unordered_set<int>())); \n            graph[connection[0]].insert(connection[1]); \n            graph.insert(make_pair(connection[1], unordered_set<int>())); \n            graph[connection[1]].insert(connection[0]); \n        }\n        \n        vector<vector<int>> ans; \n        for (auto edge : treeEdges) {\n            graph[edge[0]].erase(edge[1]); \n            graph[edge[1]].erase(edge[0]); \n            if (!reachable(edge[0], edge[1], graph)) {\n                ans.push_back(edge); \n            }\n            graph[edge[0]].insert(edge[1]); \n            graph[edge[1]].insert(edge[0]); \n        }\n        return ans; \n    }\n    \n    \n    bool reachable(int src, int dest, unordered_map<int, unordered_set<int>>& graph) {\n        unordered_set<int> visited; \n        function<bool(int,int)> dfs = [&](int src, int dest) -> bool {\n            if (visited.find(src) != visited.end()) {\n                return false; \n            }\n            \n            if (src == dest) {\n                return true; \n            }\n            \n            visited.insert(src); \n            \n            for (int n : graph[src]) {\n                if (dfs(n, dest)) {\n                    return true; \n                } \n            }\n            return false; \n        };\n        \n        return dfs(src, dest); \n    }\n};","compare_result":"111111111000","title_slug":"critical-connections-in-a-network"}