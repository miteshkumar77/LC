{"id":317709717,"lang":"cpp","time":"2Â years","timestamp":1585629461,"status_display":"Accepted","runtime":"24 ms","url":"/submissions/detail/317709717/","is_pending":"Not Pending","title":"Word Break","memory":"13 MB","code":"\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict,int n ,int m,int idx,unordered_map<string,bool>& M,int* memo){\n        //Base Case\n        if(idx==n){\n            return true;\n        }\n        if(memo[idx]!=-1){\n            return memo[idx];\n        }\n        string str=\"\";\n        //First I have to check word in my dictionary\n        bool ans=false;\n        for(int i=idx;i<n;i++){\n            str+=s[i];\n            //If we found some word in map\n            //Then we have 2 options\n            //Option 1:- Use that word and move to next index\n            if(M[str]){\n                ans=ans||wordBreak(s,wordDict,n,m,i+1,M,memo);\n            }\n            //Option 2:- Find some other word\n        }\n        memo[idx]=ans;\n        return memo[idx];\n    }\n    bool wordBreak(string s, vector<string>& wordDict) {\n        int n=s.size(),m=wordDict.size();\n        //I will make an unordered map and put all words in it\n        //Now I dont even need to sort my wordDict\n        unordered_map<string,bool> M;\n        for(int i=0;i<m;i++){\n            M[wordDict[i]]=true;\n        }\n        int *memo=new int[n+1];\n        for(int i=0;i<=n;i++){\n            memo[i]=-1;\n        }\n        return wordBreak(s,wordDict,n,m,0,M,memo);\n    }\n};\n","compare_result":"111111111111111111111111111111111111","title_slug":"word-break"}