{"id":541026646,"lang":"cpp","time":"8Â months","timestamp":1629392886,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/541026646/","is_pending":"Not Pending","title":"Regular Expression Matching","memory":"6.8 MB","code":"class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.length(); int m = p.length();\n        vector<vector<bool>> dp(n+1, vector<bool>(m+1, 0));\n        dp[0][0] = true;\n        for (int i = 1; i <= m; ++i) {\n            dp[0][i] = p[i-1] == '*' && dp[0][i-2];\n        }\n        for (int s_p = 1; s_p <= n; ++s_p) {\n            for (int p_p = 1; p_p <= m; ++p_p) {\n                if (p[p_p-1] == '.' || p[p_p-1] == s[s_p-1]) {\n                    dp[s_p][p_p] = dp[s_p-1][p_p-1];\n                } else if (p[p_p-1] == '*') {\n                    bool can_skip = dp[s_p][p_p-2];\n                    bool prev_matches = p[p_p-2] == s[s_p-1] || p[p_p-2] == '.';\n                    bool first_match = prev_matches && dp[s_p-1][p_p-1];\n                    bool repeated_match = prev_matches && dp[s_p-1][p_p];\n                    dp[s_p][p_p] = can_skip || first_match || repeated_match;\n                }\n            }\n        }\n        return dp[n][m];\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"regular-expression-matching"}