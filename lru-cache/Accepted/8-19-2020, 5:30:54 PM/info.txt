{"id":383397678,"lang":"cpp","time":"1 year, 8 months","timestamp":1597872654,"status_display":"Accepted","runtime":"280 ms","url":"/submissions/detail/383397678/","is_pending":"Not Pending","title":"LRU Cache","memory":"42.1 MB","code":"class LRUCache {\npublic:\n    LRUCache(int capacity) {\n        cap = capacity; \n    }\n    \n    int get(int key) {\n        auto it = mp.find(key); \n        if (it == mp.end()) {\n            return -1; \n        }\n        \n        int ret = (it -> second).second; \n        lst.erase((it -> second).first); \n        lst.push_front(it -> first);\n        (it -> second).first = lst.begin(); \n        return ret; \n    }\n    \n    void put(int key, int value) {\n        auto it = mp.find(key); \n        if (it != mp.end()) {\n            (it -> second).second = value; \n            get(key); \n            return; \n        } else {\n            lst.push_front(key); \n            mp[key] = make_pair(lst.begin(), value); \n        }\n        \n        if (lst.size() > cap) {\n            int eject = lst.back(); \n            lst.pop_back(); \n            mp.erase(eject); \n        }\n    }\nprivate: \n    \n    unordered_map<int, pair<list<int>::iterator, int>> mp; \n    list<int> lst; \n    int cap; \n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"111111111111111111","title_slug":"lru-cache"}