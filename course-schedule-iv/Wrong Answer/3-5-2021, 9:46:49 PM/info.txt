{"id":464068866,"lang":"cpp","time":"1 year, 1 month","timestamp":1614998809,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/464068866/","is_pending":"Not Pending","title":"Course Schedule IV","memory":"N/A","code":"class Solution {\npublic:\n    \n    void dfs(vector<vector<int>>& graph, vector<unordered_map<int,int>>& parents, int node, int parent, int depth) {\n        parents[node][parent] = depth;\n        for (int neighbor : graph[node]) {\n            dfs(graph, parents, neighbor, parent, depth + 1);\n        }\n    }\n    \n    vector<bool> checkIfPrerequisite(int n, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n        vector<unordered_map<int, int>> parents(n);\n        vector<vector<int>> graph(n);\n        vector<int> indegree(n);\n        for (auto& e : prerequisites) {\n            graph[e[0]].push_back(e[1]);\n            ++indegree[e[1]];\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            if (indegree[i] == 0) {\n                dfs(graph, parents, i, i, 0);\n            }\n        }\n        \n        vector<bool> ans;\n        ans.reserve(queries.size()); \n        \n        for (auto& e : queries) {\n            bool ok = false;\n            for (auto& p : parents[e[0]]) {\n                if (parents[e[1]].count(p.first) && parents[e[1]][p.first] > p.second) {\n                    ok = true;\n                    break;\n                }\n            }\n            ans.push_back(ok);\n        }\n        return ans;\n        \n    }\n};","compare_result":"11111101000000000000000000000000000000000000000000000000000000000000","title_slug":"course-schedule-iv"}